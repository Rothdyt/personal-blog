---
title: "无约束优化(5)"
author: Yutong Dai
date: '2016-11-02'
categories:
  - convex optimization
tags:
  - 无约束优化
slug: uncon5
output:
  blogdown::html_page:
    toc: yes
summary: 该系列posts是笔者学习Dimitri .P Bertsekas所写的 Nonlinear Programming 2ed 中文版时整理的笔记。第一章无约束优化内容涉及到最优性条件、梯度方法、牛顿法与变形以及共轭方向法。本文讨论共轭方向法。
---


<div id="TOC">
<ul>
<li><a>共轭方向法</a><ul>
<li><a>共轭方向法求解二次问题</a></li>
<li><a>共轭方向法求解非二次问题</a></li>
</ul></li>
</ul>
</div>

<div class="section level2">
<h2>共轭方向法</h2>
<p>在前面的讨论中我们看到了，由于最速下降法在矩阵条件数大的情况下，收敛速率可以非常缓慢；牛顿法虽然在非奇异驻点附近收敛速率很快，但是计算复杂度较高。因此我们提出了共轭方向法（conjugate direction methods）来改进该问题。</p>
<p>首先给出共轭的概念与简单性质</p>
<ul>
<li><p>定义： 给定一个n维的正定矩阵<span class="math inline">\(Q\)</span>，我们说非零向量组<span class="math inline">\(d_1,...,d_k\)</span>是Q-共轭(Q-conjugate)的，如果任意<span class="math inline">\(i\neq j\)</span>成立</p>
<p><span class="math display">\[d_i^TQd_j=0\]</span></p></li>
<li><p>性质： 如果非零向量组<span class="math inline">\(d_1,...,d_k\)</span>是Q-共轭，则它们是线性无关的</p></li>
</ul>
<p><strong>Remark</strong> 其实Q-共轭可以看作是在另一坐标系下的的正交。因为，若设<span class="math inline">\(Q=A^TA\)</span>,则有<span class="math inline">\((Ad_i)^T(Ad_j)=0\)</span></p>
<div class="section level3">
<h3>共轭方向法求解二次问题</h3>
<p>对于一个给定含有n个Q-共轭方向<span class="math display">\[\{d_0,d_1,...,d_{n-1}\}\]</span>，以及无约束二次函数最小化问题</p>
<p><span class="math display">\[\mathop{min}_{x} f(x)=\frac{1}{2}x&#39;Qx-b&#39;x\]</span></p>
<p>相应的共轭法为</p>
<p><span class="math display">\[x_{k+1}=x_{k}+a_kd_k\;k=0,1,...,n-1\]</span></p>
<p>其中<span class="math inline">\(x_0\)</span>是任意的初始向量，<span class="math inline">\(a_k\)</span>是按照最小步长准则给出的，即</p>
<p><span class="math display">\[a_k=\mathop{argmin}_{a} g(a)=f(x_k+ad_k)\]</span></p>
<p><strong>Remark</strong></p>
<ol style="list-style-type: decimal">
<li><p>求解方程 <span class="math inline">\(g&#39;(a)=d_k^T\nabla (x_k+a_kd_k)=0\)</span>【原问题是凸的，故可以使用一阶最优性条件】,可以给出每一步长</p>
<p><span class="math display">\[a_k=\frac{d_k^T(b-Qx_k)}{d_k^TQd_k}\]</span></p></li>
<li><p>从代数的观点来看，共轭方向法的本质是：<strong>在逐渐扩张的线性流形上逐步极小化目标函数<span class="math inline">\(f\)</span>,而经过n步扩张后的线性流形将包含<span class="math inline">\(f\)</span>的全局最小值点</strong>，即对每一个k（k=0,1,2,..,n-1）</p>
<p><span class="math display">\[x_{k+1}=\mathop{argmin}_{x\in M_k}\quad f(x)\]</span></p>
<p>其中<span class="math display">\[M_K=\{x_0+v\vert v\in span\{d_0,d_1,..d_k\}\}\]</span>。因为我们可以证明该优化问题求解出来的<span class="math inline">\(x_{k+1}\)</span>就是更新公式产生的那个<span class="math inline">\(x_{k+1}\)</span>。特别地，在证明过程中，我们顺便得到</p>
<p><span class="math display">\[d_i^T\nabla f(x_{k+1})=0\quad \forall i=0,1,2,...,k\]</span></p></li>
<li><p>从几何的观点来看，共轭方向法实质：<strong>在n维空间中，逐渐沿着n个正交方向，极小化目标函数<span class="math inline">\(f\)</span></strong>。具体来讲，当<span class="math inline">\(b=0, Q=I\)</span>时，这时<span class="math inline">\(f\)</span>的等值面是同心球，我们沿着n个正交方向（比如坐标轴方向）逐次极小化<span class="math inline">\(f\)</span>便可以的达到球心。如果<span class="math inline">\(Q\)</span>是一般的正定矩阵，可以通过尺度变换，令<span class="math inline">\(y=Q^{1/2}x\)</span>则极小化</p>
<p><span class="math display">\[\frac{1}{2}x&#39;Qx\]</span></p>
<p>等价于极小化<span class="math inline">\(\vert \vert y\vert \vert ^2\)</span>。如果<span class="math inline">\(w_0.w_1,..w_{n-1}\)</span>是<span class="math inline">\(R^n\)</span>中的一组非零正交方向算法最多在n步后终止。利用<span class="math inline">\(x=Q^{-1/2}y\)</span>即可求解原问题。</p></li>
</ol>
<div class="figure">
<img src="http://ogfa13jyv.bkt.clouddn.com/Snip20161031_3.png" alt="Snip20161031_3" />
<p class="caption">Snip20161031_3</p>
</div>
<div id="q-" class="section level4">
<h4>Q-共轭方向的生成</h4>
<p>对于任意给定的线性无关向量组<span class="math display">\[\{\xi_0,\xi_1,...,\xi_k\}\]</span>，利用Gram-Schmidt方法，可以构建一组相互Q-共轭的方向<span class="math display">\[\{d_0,d_1,...,d_k\}\]</span>，使得对于所有的<span class="math inline">\(i=0,...,k\)</span>满足</p>
<p><span class="math display">\[span\{\xi_0,\xi_1,...,\xi_i\}=span\{d_0,d_1,...,d_i\} \qquad(1.147)\]</span></p>
<p><img src="http://ogfa13jyv.bkt.clouddn.com/Snip20161102_3.png" alt="Snip20161102_3" /> <img src="http://ogfa13jyv.bkt.clouddn.com/Snip20161102_4.png" alt="Snip20161102_4" /></p>
</div>
<div class="section level4">
<h4>共轭梯度法</h4>
<p>该方法是基于在第k步的梯度方向<span class="math inline">\(g_k=\nabla f(x_k)\)</span>,来生成共轭方向<span class="math inline">\(d_k\)</span>。具体来说是：</p>
<p>设<span class="math inline">\(\xi_0=-g_0\)</span>, <span class="math inline">\(d_0=\xi_0\)</span> 假设已经得到了k-1个共轭方向<span class="math display">\[\{d_0,d_1,...,d_{k-1}\}\]</span>，利用Gram-Schimidt方法对向量组<span class="math display">\[\{-g_k,d_0,...,d_{k-1}\}\]</span>执行（1.149）和（1.151）式得到共轭方向</p>
<p><span class="math display">\[d_k=-g_k+\sum_{i=1}^{k-1}\frac{g_k&#39;Qd_i}{d_i&#39;Qd_i}d_i\]</span></p>
<p>利用最小化步长准则选取步长<span class="math inline">\(a_k\)</span>，从而构造迭代列</p>
<p><span class="math display">\[x_{k+1}=x_k+a_kd_k\]</span></p>
<p><strong>Remark</strong></p>
<ol style="list-style-type: decimal">
<li><p>若<span class="math inline">\(g_0\neq0\)</span>,算法在终止之前所有生成的梯度<span class="math inline">\(g_k\)</span>是线性无关的。这是由<em>共轭方向本质上是在逐渐扩张的线性流形上逐步极小化目标函数</em>这一原理保证的。事实上若在第k步，算法未终止，<span class="math inline">\(\forall i=0,1,...,k-1\)</span>我们有<span class="math inline">\(d_i^Tg_k=0\quad\)</span>。而<span class="math display">\[span \{d_0,d_1,...,d_{k-1}\}= span \{g_0,g_1,...,g_{k-1}\}\]</span>，故<span class="math inline">\(\forall i=0,1,...,k-1\)</span></p>
<p><span class="math display">\[g_i^Tg_k=0\]</span></p></li>
<li><p>由于最多能够n个线性无关的梯度方向，故至多迭代n次后，梯度为零，且算法会帮助找到某个全局最小值。</p></li>
<li><p>共轭梯度法之所以有用是因为，看似计算十分复杂的共轭方向<span class="math inline">\(d_k\)</span>的生成公式</p>
<p><span class="math display">\[d_k=-g_k+\sum_{i=1}^{k-1}\frac{g_k&#39;Qd_i}{d_i&#39;Qd_i}d_i\]</span></p>
<p>可以化简为</p>
<p><span class="math display">\[d_k=-g_k+\frac{g_k&#39;g_k}{g_{k-1}&#39;g_{k-1}}d_{k-1}\]</span></p>
<p>【证明可以参见Dimitri .P Bertsekas, Nonlinear Programming 2ed中文版p105 命题1.6.1】</p></li>
<li><p>显然当<span class="math inline">\(d_k=0\)</span>时，算法也会结束。但是利用3的结论，我们可以知道只有当<span class="math inline">\(g_k=0\)</span>时才有<span class="math inline">\(d_k=0\)</span>。利用反正法，若<span class="math inline">\(d_k=0,g_k\neq 0\)</span>，我们有<span class="math inline">\(g_k=\frac{g_k&#39;g_k}{g_{k-1}&#39;g_{k-1}}d_{k-1}\)</span>，这与1中<span class="math inline">\(g_k\)</span>与<span class="math inline">\(d_{k-1}\)</span>的正交性矛盾了。</p></li>
</ol>
</div>
</div>
<div class="section level3">
<h3>共轭方向法求解非二次问题</h3>
<p>共轭方向法同样可以运用在非二次问题中，即直接将针对二次问题的算法平行的移植过来。</p>
<p><span class="math display">\[\mathop{min}_x \quad f(x)\]</span></p>
<p><code>Algorithm</code></p>
<hr />
<p><span class="math display">\[x_{k+1}=x_{k}+a_kd_k\;k=0,1,...,n-1\]</span></p>
<p>其中<span class="math inline">\(x_0\)</span>是任意的初始向量，<span class="math inline">\(a_k\)</span>是按照最小步长准则给出的，即</p>
<p><span class="math display">\[a_k=\mathop{argmin}_{a} g(a)=f(x_k+ad_k)\]</span></p>
<p><span class="math inline">\(d_k\)</span>是按照下式给出的</p>
<p><span class="math display">\[d_k=-g_k+\beta_kd_{k-1}\]</span></p>
<p>其中常用的<span class="math inline">\(\beta_k\)</span>计算方式为</p>
<p><span class="math display">\[\beta_{k}=\frac{\nabla^T f(x_k)\big(\nabla f(x_k)-\nabla f(x_{k-1})\big)}{\nabla^T f(x_{k-1})\nabla f(x_{k-1})}\]</span></p>
<hr />
<p><strong>Remark</strong></p>
<ol style="list-style-type: decimal">
<li><p>选取<span class="math inline">\(\beta_k\)</span>的直观想法是来自求解二次问题时，共轭方向的生成公式</p>
<p><span class="math display">\[d_k=-g_k+\frac{g_k&#39;g_k}{g_{k-1}&#39;g_{k-1}}d_{k-1}\]</span></p>
<p>由于<span class="math inline">\(g_k&#39;g_{k-1}=0\)</span>，故上式又等价于</p>
<p><span class="math display">\[d_k=-g_k+\frac{g_k&#39;(g_k-g_{k-1})}{g_{k-1}&#39;g_{k-1}}d_{k-1}\]</span></p></li>
<li><p><span class="math inline">\(d_k=-g_k+\beta_kd_{k-1}\)</span> 是一个下降方向，即有<span class="math inline">\(d^T_{k}\nabla f(x_k)&lt;0\)</span>.</p>
<p><em>proof:</em> 在二次问题中讨论中我们证明了，按照线性最小化方式选择步长<span class="math inline">\(a_k\)</span>以及用共轭方向<span class="math inline">\(d_k\)</span>更新<span class="math inline">\(x_{k+1}\)</span>的方式能够保证</p>
<p><span class="math display">\[d_i^T\nabla f(x_{k+1})=0\quad \forall i=0,1,2,...,k\]</span></p>
<p>于是我们有<span class="math inline">\(d_{k-1}^T\nabla f(x_{k})=0\)</span>，从而</p>
<p><span class="math display">\[d^T_{k}\nabla f(x_k)=-\vert \vert \nabla f(x_k)\vert \vert ^2+\beta_kd_{k-1}^T\nabla f(x_{k})=-\vert \vert \nabla f(x_k)\vert \vert ^2&lt;0\]</span></p></li>
<li><p>这样选取<span class="math inline">\(\beta_k\)</span>的目的在于，目标函数中存在的二次项和不精确的一维线搜索会破坏我们搜索方向<span class="math display">\[\{d_k\}\]</span>的共轭性，并且会出现<span class="math inline">\(d_k\)</span>与<span class="math inline">\(\nabla f(x_k)\)</span>近似正交的情形。一旦<span class="math inline">\(d_k\)</span>与<span class="math inline">\(\nabla f(x_k)\)</span>近似正交<span class="math inline">\(\vert \vert \nabla f(x_k)\vert \vert ^2\)</span>近似等于0。如果<span class="math inline">\(\beta_k\)</span>更新公式选成<span class="math inline">\(\beta_{k}=\frac{\nabla^T f(x_k)\big(\nabla f(x_k)\big)}{\nabla^T f(x_{k-1})\nabla f(x_{k-1})}\)</span>，则<span class="math inline">\(\beta_k\)</span>就接近0，于是<span class="math inline">\(x_{k+1}\)</span>便近似等于<span class="math inline">\(x_k\)</span>,导致迭代算法被卡住。</p></li>
<li><p>另外<br />
<img src="http://ogfa13jyv.bkt.clouddn.com/Snip20161102_6.png" alt="Snip20161102_6" /></p></li>
</ol>
</div>
</div>
